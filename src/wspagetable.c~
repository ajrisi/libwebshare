/* file should contain all of the page posting functions */
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>

#include "wspagetable.h"
#include "wsserver.h"

int webpage_table_item_compare( void *li, void *ri) 
{
  webpage_table_item *left = li;
  webpage_table_item *right = ri;
  return strcmp(left->key, right->key);
}

void *webpage_table_item_dup(void *it) 
{
  webpage_table_item *old_item = it;
  webpage_table_item *new_item = malloc(sizeof(webpage_table_item));
  if(new_item == NULL) return NULL;
  new_item->key = strdup(old_item->key);
  if(new_item->key == NULL) {
    free(new_item);
    return NULL;
  }
  new_item->postitem_type = old_item->postitem_type;
  new_item->value = old_item->value;

  //need to do a deep copy of the buffer if the post item is a buffer
  if(old_item->postitem_type == POSTITEM_BUFFER) {
    new_item->value.buffer = strdup(old_item->value.buffer);
    if(new_item->value.buffer == NULL) {
      free(new_item);
      return NULL;
    }
  }

  //do a deep copy of the file path if it is a file being served
  if(old_item->postitem_type == POSTITEM_FILE) {
    new_item->value.file_path = strdup(old_item->value.file_path);
    if(new_item->value.file_path == NULL) {
      free(new_item);
      return NULL;
    }
  }

  //we do not do a deep copy of a function pointer, there is no need to

  return (void*)new_item;
}

void webpage_table_item_free(void *it)
{
  webpage_table_item *myitem = it;
  
  free(myitem->key);

  if(myitem->postitem_type == POSTITEM_BUFFER)
    free(myitem->value.buffer);
  else if(myitem->postitem_type == POSTITEM_FILE) 
    free(myitem->value.file_path);
  
  free(myitem);
}

unsigned long webpage_table_item_hash(void *it)
{
  webpage_table_item *myitem = it;
  return hshstrhash_sdbm(myitem->key);
}

unsigned long webpage_table_item_rehash(void *it) 
{
  webpage_table_item *myitem = it;   
  return hshstrhash_rs(myitem->key);
}

int webpage_table_init( void ) 
{
  /* the 0 in this call is for future compatability on hshinit */
  webpage_table = hshinit(webpage_table_item_hash, webpage_table_item_rehash, 
			  webpage_table_item_compare, webpage_table_item_dup,
			  webpage_table_item_free, 0);

  return (webpage_table == NULL);
  
}

void webpage_table_free( void )
{
  hshkill(webpage_table);
}

webpage_table_item *webpage_table_find(char *path) 
{
 
  /* build a webpage_table_item with the right key to search for */
  webpage_table_item lookfor;
  lookfor.key = path;

  return hshfind(webpage_table, &lookfor); 
}

int webshare_post_postitem(int posttype, char *path, postitem *pi) 
{
  webpage_table_item toinsert;
  toinsert.postitem_type = posttype;
  toinsert.key = path;
  toinsert.value = *pi;

  //make sure the item is not already present
  if(webpage_table_find(path) != NULL) {
    fprintf(stderr, "webshare: collission detected on %s, already present in share?\n", path);
  } else {
    /* return 1 on failure, 0 on success */
    return hshinsert(webpage_table, &toinsert) == NULL;
  }
}

int webshare_post_function(char *path, void*(*callback)(void *data)) 
{
  postitem pi = {0};
  pi.callback = callback;
  return webshare_post_postitem(POSTITEM_FUNCTION, path, &pi);
}

int webshare_post_file(char *path, char *file_path) 
{
  printf("adding file located at %s at %s\n", file_path, path);

  postitem pi = {0};
  pi.file_path = file_path;
  return webshare_post_postitem(POSTITEM_FILE, path, &pi);
}

int webshare_post_buffer(char *path, char *buffer) 
{
  postitem pi = {0};
  pi.buffer = buffer;
  return webshare_post_postitem(POSTITEM_BUFFER, path, &pi);
}

int webshare_post_directory(char *path_prefix, char *dir_path) 
{
  printf("sharing %s with prefix %s\n", dir_path, path_prefix);

  //to post a directory, we make recursive calls to post a file
  DIR *dp;
  struct dirent *entry;

  dp = opendir(dir_path);
  if(dp == NULL) return 1;

  while((entry = readdir(dp)) != NULL) {
    /* 1024 is a hard coded limitation herer */
    char path[1024] = {0};
    sprintf(path, "%s/%s", dir_path , entry->d_name);
    if(path_is_regular(path) && !path_is_directory(path)) {
      char sharepath[1024] = {0};
      sprintf(sharepath, "%.800s/%.223s", path_prefix, entry->d_name);
      if(webshare_post_file(sharepath, path) != 0) {
	fprintf(stderr, "webshare: unable to post item at %s\n", sharepath);
	//return 1;
      }
    } 
    if(path_is_directory(path)) {
      char sharepath[1024] = {0};
      if(strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0 ) {
	sprintf(sharepath, "%.800s/%.223s", path_prefix, entry->d_name);
	if(webshare_post_directory(sharepath, path) != 0) {
	  fprintf(stderr, "webshare: unable to post item at %s\n", sharepath);
	  //return 1;
	}
      }
    }
  }

  closedir(dp);  
  return 0;
}


void webpage_table_drop(hshtbl *webpage_table, char *path)
{
  /* build a webpage_table_item with the right key to search for */
  webpage_table_item lookfor;
  lookfor.key = path;

  webpage_table_item *item = hshfind(webpage_table, &lookfor);
  if(item != NULL)
    webpage_table_item_free(item);
}

webpage_table_stats webpage_table_status(hshtbl *webpage_table) 
{
  webpage_table_stats stat = {0};
  hshstats raw_stats = hshstatus(webpage_table);

  stat.probes = raw_stats.probes;
  stat.entries = raw_stats.hentries;
  stat.misses = raw_stats.misses;
  stat.deletions = raw_stats.hdeleted;

  return stat;
}


#ifdef WSPAGETABLETEST

#include "../wshashlib.h"

hshtbl *webpage_table;

int main(int argc, char **argv) {

  webpage_table_init();

  if(webshare_post_file("/myfile", "/home/adam/test.html") != 0) {
    fprintf(stderr, "Could not post item at /myfile\n");
    exit(1);
  }
  
  if(webshare_post_directory("/mydir", "/media/terabyte") != 0) {
    fprintf(stderr, "Failed at posting directory\n");
    exit(1);
  }

  if(webshare_post_file("/mydir/libwebshare/Makefile", "/home/adam/coding_projects/libwebshare/Makefile") != 0) {
    printf("good, a collission was detected\n");
  }

  webpage_table_item *testitem = webpage_table_find("/myfile");
  if(testitem == NULL) {
    fprintf(stderr, "Could not lookup item\n");
  } else {
    printf("Successfully looked up item at %s\n", testitem->key);
    
  }

  testitem = webpage_table_find("/notinthere");
  if(testitem == NULL) {
    fprintf(stderr, "Could not lookup item\n");
  } else {
    printf("Successfully looked up item at %s\n", testitem->key);
  }

  webpage_table_stats st = webpage_table_status();
  printf("There are currently %d pages being shared.\n", st.entries);

  webpage_table_free();

  return 0;
}

#endif
